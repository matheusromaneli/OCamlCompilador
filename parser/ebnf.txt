value-name ::= lowercase-ident ∣ (operator-name)

operator-name ::=	prefix-symbol ∣ infix-op

infix-op ::= infix-symbol  ∣ * ∣ + ∣ - ∣ -. ∣ = ∣ != ∣ < ∣ > ∣ or ∣ || ∣ & ∣ && ∣ := ∣ mod ∣ land ∣ lor ∣ lxor ∣ lsl ∣ lsr ∣ asr
 
constr-name	::=	capitalized-ident
 
tag-name ::= capitalized-ident
 
typeconstr-name	::=	lowercase-ident
 
field-name ::= lowercase-ident
 
module-name	::=	capitalized-ident
 
modtype-name ::= ident
 
class-name ::=	lowercase-ident
 
inst-var-name ::= lowercase-ident
 
method-name	::=	lowercase-ident

value-path ::= [ module-path . ] value-name
 
constr ::= [ module-path . ] constr-name
 
typeconstr ::= [ extended-module-path . ] typeconstr-name
 
field ::= [ module-path . ] field-name
 
modtype-path ::=	[ extended-module-path . ] modtype-name
 
class-path	::=	[ module-path . ] class-name
 
classtype-path	::=	[ extended-module-path . ] class-name
 
module-path	::=	module-name { . module-name }
 
extended-module-path ::= extended-module-name { . extended-module-name }
 
extended-module-name ::= module-name { ( extended-module-path ) }


typexpr	::=	' ident
 	∣	 _
 	∣	 ( typexpr )
 	∣	 [[?]label-name:] typexpr -> typexpr
 	∣	 typexpr { * typexpr }+
 	∣	 typeconstr
 	∣	 typexpr typeconstr
 	∣	 ( typexpr { , typexpr } ) typeconstr
 	∣	 typexpr as ' ident
 	∣	 polymorphic-variant-type
 	∣	 < [..] >
 	∣	 < method-type { ; method-type } [; ∣ ; ..] >
 	∣	 # classtype-path
 	∣	 typexpr # class-path
 	∣	 ( typexpr { , typexpr } ) # class-path
 
poly-typexpr ::= typexpr ∣ { ' ident }+ . typexpr
 
method-type	::=	method-name : poly-typexpr

polymorphic-variant-type ::= [ tag-spec-first { | tag-spec } ]
 	∣	 [> [ tag-spec ] { | tag-spec } ]
 	∣	 [< [|] tag-spec-full { | tag-spec-full } [ > { `tag-name }+ ] ]
 
tag-spec-first ::= `tag-name [ of typexpr ]
 	∣	 [ typexpr ] | tag-spec
 
tag-spec	::=	`tag-name [ of typexpr ]
 	∣	 typexpr
 
tag-spec-full	::=	`tag-name [ of [&] typexpr { & typexpr } ]
 	∣	 typexpr


constant	::=	integer-literal
 	∣	 int32-literal
 	∣	 int64-literal
 	∣	 nativeint-literal
 	∣	 float-literal
 	∣	 char-literal
 	∣	 string-literal
 	∣	 constr
 	∣	 false
 	∣	 true
 	∣	 ()
 	∣	 begin end
 	∣	 []
 	∣	 [||]
 	∣	 `tag-name

pattern	::=	value-name
 	∣	 _
 	∣	 constant
 	∣	 pattern as value-name
 	∣	 ( pattern )
 	∣	 ( pattern : typexpr )
 	∣	 pattern | pattern
 	∣	 constr pattern
 	∣	 `tag-name pattern
 	∣	 #typeconstr
 	∣	 pattern { , pattern }+
 	∣	 { field [: typexpr] [= pattern]{ ; field [: typexpr] [= pattern] } [; _ ] [ ; ] }
 	∣	 [ pattern { ; pattern } [ ; ] ]
 	∣	 pattern :: pattern
 	∣	 [| pattern { ; pattern } [ ; ] |]
 	∣	 char-literal .. char-literal
 	∣	 lazy pattern
 	∣	 exception pattern
 	∣	 module-path .( pattern )
 	∣	 module-path .[ pattern ]
 	∣	 module-path .[| pattern |]
 	∣	 module-path .{ pattern }


expr	::=	value-path
 	∣	 constant
 	∣	 ( expr )
 	∣	 begin expr end
 	∣	 ( expr : typexpr )
 	∣	 expr { , expr }+
 	∣	 constr expr
 	∣	 `tag-name expr
 	∣	 expr :: expr
 	∣	 [ expr { ; expr } [;] ]
 	∣	 [| expr { ; expr } [;] |]
 	∣	 { field [: typexpr] [= expr]{ ; field [: typexpr] [= expr] } [;] }
 	∣	 { expr with field [: typexpr] [= expr]{ ; field [: typexpr] [= expr] } [;] }
 	∣	 expr { argument }+
 	∣	 prefix-symbol expr
 	∣	 - expr
 	∣	 -. expr
 	∣	 expr infix-op expr
 	∣	 expr . field
 	∣	 expr . field <- expr
 	∣	 expr .( expr )
 	∣	 expr .( expr ) <- expr
 	∣	 expr .[ expr ]
 	∣	 expr .[ expr ] <- expr
 	∣	 if expr then expr [ else expr ]
 	∣	 while expr do expr done
 	∣	 for value-name = expr ( to ∣ downto ) expr do expr done
 	∣	 expr ; expr
 	∣	 match expr with pattern-matching
 	∣	 function pattern-matching
 	∣	 fun { parameter }+ [ : typexpr ] -> expr
 	∣	 try expr with pattern-matching
 	∣	 let [rec] let-binding { and let-binding } in expr
 	∣	 let exception constr-decl in expr
 	∣	 let module module-name { ( module-name : module-type ) } [ : module-type ]  = module-expr in expr
 	∣	 ( expr :> typexpr )
 	∣	 ( expr : typexpr :> typexpr )
 	∣	 assert expr
 	∣	 lazy expr
 	∣	 local-open
 	∣	 object-expr



argument	::=	expr
 	∣	 ~ label-name
 	∣	 ~ label-name : expr
 	∣	 ? label-name
 	∣	 ? label-name : expr
 
pattern-matching	::=	[ | ] pattern [when expr] -> expr { | pattern [when expr] -> expr }
 
let-binding	::=	pattern = expr
 	∣	 value-name { parameter } [: typexpr] [:> typexpr] = expr
 	∣	 value-name : poly-typexpr = expr 
 
parameter	::=	pattern
 	∣	 ~ label-name
 	∣	 ~ ( label-name [: typexpr] )
 	∣	 ~ label-name : pattern
 	∣	 ? label-name
 	∣	 ? ( label-name [: typexpr] [= expr] )
 	∣	 ? label-name : pattern
 	∣	 ? label-name : ( pattern [: typexpr] [= expr] )


local-open	::=	 
 	∣	 let open module-path in expr
 	∣	 module-path .( expr )
 	∣	 module-path .[ expr ]
 	∣	 module-path .[| expr |]
 	∣	 module-path .{ expr }
 	∣	 module-path .{< expr >}
 
object-expr	::=	 
 	∣	 new class-path
 	∣	 object class-body end
 	∣	 expr # method-name
 	∣	 inst-var-name
 	∣	 inst-var-name <- expr
 	∣	 {< [ inst-var-name [= expr] { ; inst-var-name [= expr] } [;] ] >}


type-definition	::=	type [nonrec] typedef { and typedef }
 
typedef	::=	[type-params] typeconstr-name type-information
 
type-information	::=	[type-equation] [type-representation] { type-constraint }
 
type-equation	::=	= typexpr
 
type-representation	::=	= [|] constr-decl { | constr-decl }
 	∣	 = record-decl
 	∣	 = |
 
type-params	::=	type-param
 	∣	 ( type-param { , type-param } )
 
type-param	::=	[ext-variance] ' ident
 
ext-variance	::=	variance [injectivity]
 	∣	 injectivity [variance]
 
variance	::=	+
 	∣	 -
 
injectivity	::=	 !
 
record-decl	::=	{ field-decl { ; field-decl } [;] }
 
constr-decl	::=	(constr-name ∣ [] ∣ (::)) [ of constr-args ]
 
constr-args	::=	typexpr { * typexpr }
 
field-decl	::=	[mutable] field-name : poly-typexpr
 
type-constraint	::=	constraint typexpr = typexpr


exception-definition	::=	exception constr-decl
 	∣	 exception constr-name = constr


class-type	::=	[[?]label-name:] typexpr -> class-type
 	∣	   class-body-type
 
class-body-type	::=	object [( typexpr )] { class-field-spec } end
 	∣	  [[ typexpr { , typexpr } ]] classtype-path
 	∣	  let open module-path in class-body-type
 
class-field-spec	::=	inherit class-body-type
 	∣	  val [mutable] [virtual] inst-var-name : typexpr
 	∣	  val virtual mutable inst-var-name : typexpr
 	∣	  method [private] [virtual] method-name : poly-typexpr
 	∣	  method virtual private method-name : poly-typexpr
 	∣	  constraint typexpr = typexpr


class-expr	::=	class-path
 	∣	  [ typexpr { , typexpr } ] class-path
 	∣	  ( class-expr )
 	∣	  ( class-expr : class-type )
 	∣	  class-expr { argument }+
 	∣	  fun { parameter }+ -> class-expr
 	∣	  let [rec] let-binding { and let-binding } in class-expr
 	∣	  object class-body end
 	∣	  let open module-path in class-expr
 
class-field	::=	inherit class-expr [as lowercase-ident]
 	∣	  inherit! class-expr [as lowercase-ident]
 	∣	  val [mutable] inst-var-name [: typexpr] = expr
 	∣	  val! [mutable] inst-var-name [: typexpr] = expr
 	∣	  val [mutable] virtual inst-var-name : typexpr
 	∣	  val virtual mutable inst-var-name : typexpr
 	∣	  method [private] method-name { parameter } [: typexpr] = expr
 	∣	  method! [private] method-name { parameter } [: typexpr] = expr
 	∣	  method [private] method-name : poly-typexpr = expr
 	∣	  method! [private] method-name : poly-typexpr = expr
 	∣	  method [private] virtual method-name : poly-typexpr
 	∣	  method virtual private method-name : poly-typexpr
 	∣	  constraint typexpr = typexpr
 	∣	  initializer expr

class-body	::=	  [( pattern [: typexpr] )] { class-field }

expr	::=	…
 	∣	 inst-var-name <- expr
 	∣	 {< [ inst-var-name = expr { ; inst-var-name = expr } [;] ] >}

class-definition	::=	class class-binding { and class-binding }
 
class-binding	::=	[virtual] [[ type-parameters ]] class-name { parameter } [: class-type]  = class-expr
 
type-parameters	::=	' ident { , ' ident }

class-specification	::=	class class-spec { and class-spec }
 
class-spec	::=	[virtual] [[ type-parameters ]] class-name : class-type

classtype-definition	::=	class type classtype-def { and classtype-def }
 
classtype-def	::=	[virtual] [[ type-parameters ]] class-name = class-body-type

module-type	::=	modtype-path
 	∣	 sig { specification [;;] } end
 	∣	 functor ( module-name : module-type ) -> module-type
 	∣	 module-type -> module-type
 	∣	 module-type with mod-constraint { and mod-constraint }
 	∣	 ( module-type )
 
mod-constraint	::=	type [type-params] typeconstr type-equation { type-constraint }
 	∣	 module module-path = extended-module-path
 
specification	::=	val value-name : typexpr
 	∣	 external value-name : typexpr = external-declaration
 	∣	 type-definition
 	∣	 exception constr-decl
 	∣	 class-specification
 	∣	 classtype-definition
 	∣	 module module-name : module-type
 	∣	 module module-name { ( module-name : module-type ) } : module-type
 	∣	 module type modtype-name
 	∣	 module type modtype-name = module-type
 	∣	 open module-path
 	∣	 include module-type


module-expr	::=	module-path
 	∣	 struct [ module-items ] end
 	∣	 functor ( module-name : module-type ) -> module-expr
 	∣	 module-expr ( module-expr )
 	∣	 ( module-expr )
 	∣	 ( module-expr : module-type )
 
module-items	::=	{ ;; } ( definition ∣ expr ) { { ;; } ( definition ∣ ;; expr) } { ;; }
 
definition	::=	let [rec] let-binding { and let-binding }
 	∣	 external value-name : typexpr = external-declaration
 	∣	 type-definition
 	∣	 exception-definition
 	∣	 class-definition
 	∣	 classtype-definition
 	∣	 module module-name { ( module-name : module-type ) } [ : module-type ]  = module-expr
 	∣	 module type modtype-name = module-type
 	∣	 open module-path
 	∣	 include module-expr

unit-interface	::=	 { specification [;;] }
 
unit-implementation	::=	 [ module-items ]
